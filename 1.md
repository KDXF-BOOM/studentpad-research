# 科大讯飞AI学习机搞机教程及一些工具

* 警告：该项目并未成熟，普通人仅需看hack软件安装的这一部分即可。后面的建议有一定搞机基础的人来阅读

本项目欢迎大佬开issue来纠正我的一些语言以及提供新的思路

## 展讯机型

* T10、X2Pro、X3Pro、T20、C10、C10Pro

Soc：都为展讯的ud710_2h10（虎贲t740）

### hacking进程

#### hacking第三方应用安装（又称：升级软件法）(绝大部分人只需要看这一部分就行)

##### 思路

* 制作可以打开隐藏的activity的apk（包名得是应用商店可下载的软件的包名，且将版本号更改为9999999999），然后拿钉钉、QQ、微信等聊天软件传上去，进行“更新”，后面通过这个途径进入EngineerMode，从而达到开启adb的效果。

上述办法失效机型：X2Pro（新版本），T20，T20Pro，T10（1.07.8）

T10等其他机型目前仍可以破解，且建议在破解后删除“系统更新”应用，命令如下：

```
adb shell pm uninstall -k --user 0 com.iflytek.study.ota
```

这样是为了防止KDXF官方后续对该方法完全的封杀

#### 获取学习机的root（即刷入Magisk）

##### 为何要把root部分拿出来讲呢？因为这学习机的boot无法patch（原因是没有ramdisk）

有两种可能的方法：system分区植入magisk法和patch rec镜像法

##### system分区植入magisk法

system分区植入magisk法的大概思路就是将magisk安装到安卓system分区，可以参考[某酷安大佬写的方案（Magisk system root部分）](https://github.com/TomKing062/CVE-2022-38694_unlock_bootloader/wiki/Magisk)

原文如下（防删）：

> # Magisk system mode
>
> this can be turned to a github action, but currently this needs another device rooted with Magisk Delta (system mode)
>
> ## part 1
>
> find which file is used by your system
>
> * /vendor/etc/selinux/precompiled_sepolicy
> * /system_root/odm/etc/selinux/precompiled_sepolicy
> * /system/etc/selinux/precompiled_sepolicy
> * /system_root/sepolicy
> * /system_root/sepolicy_debug
> * /system_root/sepolicy.unlocked
>
> patch your sepolicy
>
> ```
> magiskinit --patch-sepol sepol.in sepol.out
> ```
>
> ## part 2 (use unpack tool or mount image on linux)
>
> overwrite sepol.out back to device partition
>
> cp /system/etc/init/bootanim.rc and /system/etc/init/magisk from rooted device to unrooted device's partition
>
> remember to add/change properties(owner, permission, selinux context) for them
>
> write partition back by spd_dump or fastboot(d)
>
> owner and permission
>
> ```
> system/system/etc/init/magisk/magisk32 0 0 0700
> system/system/etc/init/magisk/magisk64 0 0 0700
> system/system/etc/init/magisk/magiskpolicy 0 0 0700
> system/system/etc/init/magisk/magiskinit 0 0 0700
> system/system/etc/init/magisk/stub.apk 0 0 0700
> system/system/etc/init/magisk/config 0 0 0700
> system/system/etc/init/magisk 0 0 0700
> ```
>
> selinux context
>
> ```
> /system/system/etc/init/magisk u:object_r:system_file:s0
> /system/system/etc/init/magisk/config u:object_r:system_file:s0
> /system/system/etc/init/magisk/magisk32 u:object_r:system_file:s0
> /system/system/etc/init/magisk/magisk64 u:object_r:system_file:s0
> /system/system/etc/init/magisk/magiskinit u:object_r:system_file:s0
> /system/system/etc/init/magisk/magiskpolicy u:object_r:system_file:s0
> /system/system/etc/init/magisk/stub\.apk u:object_r:system_file:s0
> ```
>
> content of config
>
> ```
> SYSTEMMODE=true
> RECOVERYMODE=false
> ```
>
> content added to original bootanim.rc
>
> ```
> on post-fs-data
>     start logd
>     exec u:r:su:s0 root root -- /system/etc/init/magisk/magiskpolicy --live --magisk
>     exec u:r:magisk:s0 root root -- /system/etc/init/magisk/magiskpolicy --live --magisk
>     exec u:r:update_engine:s0 root root -- /system/etc/init/magisk/magiskpolicy --live --magisk
>     exec u:r:su:s0 root root -- /system/etc/init/magisk/magisk64 --auto-selinux --setup-sbin /system/etc/init/magisk /sbin
>     exec u:r:su:s0 root root -- /sbin/magisk --auto-selinux --post-fs-data
>
> on nonencrypted
>     exec u:r:su:s0 root root -- /sbin/magisk --auto-selinux --service
>
> on property:vold.decrypt=trigger_restart_framework
>     exec u:r:su:s0 root root -- /sbin/magisk --auto-selinux --service
>
> on property:sys.boot_completed=1
>     mkdir /data/adb/magisk 755
>     exec u:r:su:s0 root root -- /sbin/magisk --auto-selinux --boot-complete
>    
> on property:init.svc.zygote=restarting
>     exec u:r:su:s0 root root -- /sbin/magisk --auto-selinux --zygote-restart
>    
> on property:init.svc.zygote=stopped
>     exec u:r:su:s0 root root -- /sbin/magisk --auto-selinux --zygote-restart
> ```
>

##### 修补rec法

就是把recovery分区用RD提出来，然后用magisk修补下，但可惜，修补后的镜像无法用fastboot\spd_dump工具刷进去


### 附录：一些资源及其使用方法/作用

#### SPD_Driver

Link：[Download SPD Driver R4.20.4201 (UniSoc Driver) (androiddatahost.com)](https://androiddatahost.com/dsa6h)

作用：ADB驱动+展讯下载模式的驱动

使用方法：下载安装即可

注：macOS、Linux不需要安装这个东西

#### Research Download

Link：[Research Tool - SPD Flash Tool](https://spdflashtool.com/category/research-tool)

作用：读取分区、刷入分区（很危险！）

我推荐用R25.20.3901这个版本，因为它比较稳定

用法：[使用ResearchDownload为展讯机型提取镜像 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv24981169/?jump_opus=1)

    总之就是你需要pac刷机包才能用

弊端：你必须得先做个包或者先拿同SoC（比如ud710）的fdl才行，还有每次回读操作都太麻烦了，但如果不遵守就有很大可能性会出问题（比如刷砖。售后刷机一次60）

#### spd_dump及CVE-2022-38694_unlock_bootloader项目

Link：[GitHub - TomKing062/CVE-2022-38694_unlock_bootloader](https://github.com/TomKing062/CVE-2022-38694_unlock_bootloader)

作用：提供了第二种进行读写设备分区操作的工具，但它是命令行的；提供了一种强解bootloader的方法（SoC漏洞），研究出来可以搞升级软件法不支持的机型安装软件；可以用这个读取平板的分区表（数据单位为MB）

用法（对于我们学习机而言）

```
spd_dump fdl fdl1.bin 0x5500 fdl fdl2.bin 0x9efffe00 exec <read_part/write_part/erase_part> <partition_name（分区名称）>  0 <size（分区大小，是个单位都行，比如M（MB）、K（KB），等等）>
```

注：write_part\erase_part 不需要写 0 `<size>` 这一部分
